import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "@/db/database.types";

/**
 * Custom error class for quota-related errors
 */
export class QuotaExceededError extends Error {
  public readonly hoursUntilReset: number;

  constructor(message: string, hoursUntilReset: number) {
    super(message);
    this.name = "QuotaExceededError";
    this.hoursUntilReset = hoursUntilReset;
  }
}

/**
 * Custom error class for quota service errors
 */
export class QuotaServiceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "QuotaServiceError";
  }
}

/**
 * Result type for checkQuota function
 */
export interface QuotaCheckResult {
  canGenerate: boolean;
  quotaRemaining: number;
  currentCount: number;
  hoursUntilReset: number;
}

/**
 * Result type for recordGeneration function
 */
export interface RecordGenerationResult {
  generationLogId: string;
  quotaRemaining: number;
  generationsCount: number;
}

/**
 * Internal type for check_quota RPC response
 */
interface CheckQuotaRPCResponse {
  can_generate: boolean;
  quota_remaining: number;
  current_count: number;
  hours_until_reset: number;
}

/**
 * Internal type for record_generation RPC response
 */
interface RecordGenerationRPCResponse {
  generation_log_id: string;
  generations_count: number;
  quota_remaining: number;
}

/**
 * Check if user has available quota for flashcard generation
 *
 * This function calls the Supabase RPC `check_quota` which:
 * 1. Performs lazy reset if 24+ hours have passed since last reset
 * 2. Checks if user has quota available (max 10 generations per 24h)
 * 3. Returns quota information without consuming any quota
 *
 * This is a read-only operation with no side effects on the quota counter.
 * Only the reset timer may be updated if 24h have passed.
 *
 * @param supabase - Supabase client instance (from context.locals)
 * @param userId - User ID to check quota for
 * @returns Promise<QuotaCheckResult> - Quota status information
 * @throws QuotaServiceError - For database errors or unexpected failures
 *
 * @example
 * const result = await checkQuota(supabase, userId);
 * if (result.canGenerate) {
 *   // Proceed with generation
 * } else {
 *   // Show quota exceeded error
 * }
 */
export async function checkQuota(supabase: SupabaseClient<Database>, userId: string): Promise<QuotaCheckResult> {
  try {
    // Validate input
    if (!userId) {
      throw new QuotaServiceError("User ID is required");
    }

    // Call the Supabase RPC function
    const { data: rpcResponse, error: rpcError } = await supabase.rpc("check_quota");

    // Handle RPC errors
    if (rpcError) {
      console.error("RPC check_quota error:", {
        message: rpcError.message,
        code: rpcError.code,
        details: rpcError.details,
        hint: rpcError.hint,
        userId,
      });

      throw new QuotaServiceError(`Database error: ${rpcError.message}`);
    }

    // Validate response data
    if (!rpcResponse) {
      throw new QuotaServiceError("No response returned from check_quota RPC function");
    }

    // Parse the JSON response
    const parsedResponse = rpcResponse as unknown as CheckQuotaRPCResponse;

    // Return the parsed data
    return {
      canGenerate: parsedResponse.can_generate,
      quotaRemaining: parsedResponse.quota_remaining,
      currentCount: parsedResponse.current_count,
      hoursUntilReset: parsedResponse.hours_until_reset,
    };
  } catch (error) {
    // Re-throw known error types
    if (error instanceof QuotaServiceError) {
      throw error;
    }

    // Handle unexpected errors
    console.error("Unexpected error in checkQuota:", error);
    throw new QuotaServiceError("Failed to check quota due to an unexpected error");
  }
}

/**
 * Record a successful flashcard generation and consume quota
 *
 * This function calls the Supabase RPC `record_generation` which:
 * 1. Increments the user's generation counter
 * 2. Creates a generation_log entry with the actual flashcard count
 * 3. Uses optimistic locking to handle race conditions
 * 4. Returns the generation_log_id for linking saved flashcards
 *
 * The function uses optimistic locking (revalidates quota during update).
 * If quota was exceeded between check and record (race condition), it will
 * throw QuotaExceededError even though generation was successful.
 *
 * @param supabase - Supabase client instance (from context.locals)
 * @param userId - User ID to record generation for
 * @param generatedCount - Actual number of flashcards generated by AI
 * @returns Promise<RecordGenerationResult> - Generation log ID and updated quota
 * @throws QuotaExceededError - When quota limit is reached (including race conditions)
 * @throws QuotaServiceError - For database errors or unexpected failures
 *
 * @example
 * const result = await recordGeneration(supabase, userId, flashcards.length);
 * console.log(`Generation log ID: ${result.generationLogId}`);
 * console.log(`Quota remaining: ${result.quotaRemaining}`);
 */
export async function recordGeneration(
  supabase: SupabaseClient<Database>,
  userId: string,
  generatedCount: number
): Promise<RecordGenerationResult> {
  try {
    // Validate input parameters
    if (!userId) {
      throw new QuotaServiceError("User ID is required");
    }

    if (generatedCount <= 0) {
      throw new QuotaServiceError(`Generated count must be positive, got: ${generatedCount}`);
    }

    // Call the Supabase RPC function
    const { data: rpcResponse, error: rpcError } = await supabase.rpc("record_generation", {
      p_generated_count: generatedCount,
    });

    // Handle RPC errors
    if (rpcError) {
      console.error("RPC record_generation error:", {
        message: rpcError.message,
        code: rpcError.code,
        details: rpcError.details,
        hint: rpcError.hint,
        userId,
        generatedCount,
      });

      // Check if this is a quota exceeded error (from optimistic locking)
      if (rpcError.message.includes("Daily generation limit reached")) {
        // Extract hours until reset from error message
        const hoursMatch = rpcError.message.match(/Quota resets in ([\d.]+) hours/);
        const hoursUntilReset = hoursMatch ? parseFloat(hoursMatch[1]) : 24;

        throw new QuotaExceededError(
          `Daily generation limit reached (10/10). Quota resets in ${hoursUntilReset.toFixed(1)} hours.`,
          hoursUntilReset
        );
      }

      // Handle other database errors
      throw new QuotaServiceError(`Database error: ${rpcError.message}`);
    }

    // Validate response data
    if (!rpcResponse) {
      throw new QuotaServiceError("No response returned from record_generation RPC function");
    }

    // Parse the JSON response
    const parsedResponse = rpcResponse as unknown as RecordGenerationRPCResponse;

    if (!parsedResponse.generation_log_id) {
      throw new QuotaServiceError("No generation log ID in RPC response");
    }

    // Return the parsed data
    return {
      generationLogId: parsedResponse.generation_log_id,
      quotaRemaining: Math.max(0, parsedResponse.quota_remaining),
      generationsCount: parsedResponse.generations_count,
    };
  } catch (error) {
    // Re-throw known error types
    if (error instanceof QuotaExceededError || error instanceof QuotaServiceError) {
      throw error;
    }

    // Handle unexpected errors
    console.error("Unexpected error in recordGeneration:", error);
    throw new QuotaServiceError("Failed to record generation due to an unexpected error");
  }
}
